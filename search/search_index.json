{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>AI-powered python code documentation and test generation tool</p> <p> </p> <p>Write-the is an AI-powered documentation and test generation tool that leverages Generative Pre-trained Transformers (GPTs) / Large Language Models (LLMs) to automatically write tests, generate documentation, and refactor code. It is designed to streamline the development process, improve code quality, and increase productivity.</p> <p></p>"},{"location":"#real-world-examples","title":"Real-world examples","text":"<ul> <li><code>write-the docs</code> to write the docs for the <code>write-the docs</code> command \ud83e\udd16</li> <li><code>write-the mkdocs</code> to build the documentation site for <code>write-the</code> \ud83e\udd16</li> <li><code>write-the tests</code> to write tests for <code>write-the docs</code> \ud83e\udd16</li> <li><code>write-the docs</code> and <code>write-the mkdocs</code> to build documenation for <code>autoresearcher</code> \ud83e\udd16</li> <li><code>write-the docs</code> and <code>write-the mkdocs</code> to build documenation for <code>CUPCAKEAGI</code> \ud83e\udd16</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install write-the\n</code></pre> <p><code>write-the</code> should ideally be installed in an isolated enviroment with a tool like <code>pipx</code>.</p> <pre><code>pipx install write-the\n</code></pre>"},{"location":"#features","title":"Features","text":"<p>Write-the offers the following AI-driven features:</p> <ul> <li>Write-the Docs: Automatically generate documentation for your codebase, including class and function descriptions, parameter explanations, and examples.</li> <li>Write-the Tests: Create test cases for your code, ensuring thorough test coverage and better code quality.</li> <li>Write-the Convert: Convert code and data from any format into another. </li> </ul> <p>In addition write-the can also manage OpenAI models and scaffold MkDocs websites.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or higher  </li> <li>OpenAI API key</li> </ul> <p>Note</p> <p>To use <code>write-the</code> you must set an <code>OPENAI_API_KEY</code> environment variable (e.g. <code>export OPENAI_API_KEY=...</code>).</p> <p>See https://platform.openai.com/api-keys for details.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed information on available options and parameters, refer to the official (<code>write-the</code> generated) documentation.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>The main goal for write-the is to develop a generic module system to document, test, and optimise code in any language in a reliable and repatable way.</p> <p>For a detailed project roadmap, including planned features, improvements, and milestones, please see our Project Timeline (TBD).</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community. If you would like to contribute to Write-The, please follow these steps:</p> <ul> <li>Fork the repository and create a new branch for your feature or bugfix.</li> <li>Develop your changes and ensure that your code follows the project's coding standards.</li> <li>Create a pull request with a clear description of your changes and any relevant documentation.</li> <li>For more information on contributing, please see our Contributing Guide.</li> </ul>"},{"location":"#license","title":"License","text":"<p><code>write-the</code> is distributed under the terms of the MIT license.</p>"},{"location":"commands/convert/","title":"Convert code and data from any format into another using AI","text":"<p>You can use the <code>write-the convert</code> command to convert code and data from any format into another.</p> <pre><code>write-the convert [OPTIONS] IN_FILE [OUT_FILE]\n</code></pre> <p>By default the <code>write-the convert</code> command will convert the input file to the output file format using the file extension to determine the input and output format. You can use the <code>--force</code> flag to overwrite the output file if it already exists.</p> <p><pre><code>write-the convert tests/data/multiply.py multiply.rs\n</code></pre> <pre><code>$ cat multiply.rs\nfn multiply(a: i32, b: i32) -&gt; i32 {\n    a * b\n}\n</code></pre></p> <p>To give the llm model a hint about the input and output format you can use the <code>--input-format</code> and <code>--output-format</code> flags.</p> <p><pre><code>write-the convert \\\ntests/data/multiply.py \\\nmultiply.rs \\\n-o \"Verbose Rust with lots of comments\" </code></pre> <pre><code>$ cat multiply.rs\n// This is a function named 'multiply' that takes two parameters, 'a' and 'b'.\n// Both 'a' and 'b' are of type i32, which is a 32-bit integer.\n// The function returns a value of type i32.\nfn multiply(a: i32, b: i32) -&gt; i32 {\n    // The function body consists of a single expression, 'a * b'.\n    // This expression multiplies 'a' by 'b' and returns the result.\n    // In Rust, the last expression in a function is automatically returned.\n    a * b\n}\n</code></pre></p>"},{"location":"commands/docs/","title":"Automatically Generate Docstrings for yor Python Code With AI","text":"<p>The primary use case for <code>write-the</code> is to add docstrings to your Python code. You can do this using the <code>write-the docs</code> command.</p> <pre><code>write-the docs [OPTIONS] [PATH_TO_SOURCE_CODE]\n</code></pre> <p>By default the <code>write-the docs</code> command will add docstrings to all the <code>nodes</code> in the source code that are not already documented. You can run the docs command on an entire directory or a single file. </p> <pre><code>\u276f write-the docs src/\n\u2705 src/multiply.py\ndef multiply(a, b):\n    \"\"\"\n    Multiplies 2 numbers.\n    Args:\n      a (int or float): The first number to multiply.\n      b (int or float): The second number to multiply.\n    Returns:\n      int or float: The product of a and b.\n    Examples:\n      &gt;&gt;&gt; multiply(2, 3)\n      6\n      &gt;&gt;&gt; multiply(1.5, 4)\n      6.0\n    \"\"\"\nreturn a * b\n</code></pre> <p>The \u2705 indicates that the docstrings were created. If there is an error (\u274c) adding the docstrings, the error message will be printed to the console. Any nodes that already have docstrings will be skipped (\u23ed\ufe0f).</p>"},{"location":"commands/docs/#save","title":"Save","text":"<p>By default the docstrings will be printed to the console, you can use the <code>--save</code> flag to write the docstrings to the source code.</p> <pre><code>\u276f write-the docs --save src/\n\u23ed\ufe0f src/multiply_docstring.py - No nodes found, skipping file...\n\u2705 src/multiply.py\n\u2705 src/calculate.py\n</code></pre>"},{"location":"commands/docs/#generate-docs-for-specific-nodes","title":"Generate docs for specific nodes","text":"<p>A node is a function, class or class.method block. You can use the <code>--node</code> (<code>-n</code>) flag to specify which nodes to document (this will overwrite existing docstrings). </p> <pre><code>write-the docs src/ -n function_name -n class_name -n class.method_name\n</code></pre>"},{"location":"commands/docs/#force-and-update","title":"Force and Update","text":"<p>You can also use the <code>--force</code> flag to overwrite all existing docstrings in the specified folder or file.</p> <pre><code>write-the docs --force src/some_file.py\n</code></pre> <p>You can use the <code>--update</code> flag to update existing docstrings. For example the command that was used to update the docstrings in the <code>write-the</code> codebase in this commit was:</p> <pre><code>write-the docs --update --save src/\n</code></pre>"},{"location":"commands/mkdocs/","title":"Use write-the to generate a fully featured MkDocs website for your project","text":"<p>Generate a Markdown based MkDocs website with material theme for a project including an API reference page.</p> <pre><code>write-the mkdocs [OPTIONS] [PATH_TO_SOURCE_CODE]\n</code></pre> <p>The <code>write-the mkdocs</code> command will generate a <code>mkdocs.yml</code> file and a <code>docs</code> folder in the specified directory. In addition a github action workflow file will be generated to automatically build and deploy the documentation to github pages. The <code>--readme</code> flag can be used to specify the path to the readme file that will be used as the homepage for the documentation site.</p> <p><pre><code>write-the mkdocs write_the --readme README.md\n</code></pre> The above command will generate the following file structure:</p> <pre><code>.\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u2514\u2500\u2500 reference\n\u2502       \u251c\u2500\u2500 cli.md\n\u2502       \u251c\u2500\u2500 commands.md\n\u2502       \u251c\u2500\u2500 cst.md\n\u2502       \u251c\u2500\u2500 errors.md\n\u2502       \u251c\u2500\u2500 llm.md\n\u2502       \u251c\u2500\u2500 models.md\n\u2502       \u2514\u2500\u2500 utils.md\n\u2514\u2500\u2500 .github\n    \u2514\u2500\u2500 workflows\n        \u2514\u2500\u2500 mkdocs.yml\n</code></pre> <p>You can see the documentation site that was generated for the <code>write-the</code> codebase here.</p>"},{"location":"commands/model/","title":"Mange the default model used by <code>write-the</code>","text":"<p>View and set the default model that <code>write-the</code> uses to generate documentation and tests.</p> <pre><code>write-the model [OPTIONS] [DESIRED_MODEL] </code></pre> <p>The default model that <code>write-the</code> uses to generate documentation and tests is <code>gpt-3.5-turbo-instruct</code>.</p> <p>You can also use the <code>write-the model &lt;desired_model&gt;</code> command to set the default model that <code>write-the</code> uses to generate documentation and tests. </p> <pre><code>write-the model gpt-4\n</code></pre> <p>Use the <code>--list</code> flag to view all available models.</p> <pre><code>write-the model --list\n</code></pre>"},{"location":"commands/tests/","title":"Automatically generate test cases for your codebase using AI","text":"<p>You can use the <code>write-the tests</code> command to automatically generate test cases for your codebase. The tests will use the <code>pytest</code> framework.</p> <pre><code>write-the tests [OPTIONS] [PATH_TO_SOURCE_CODE]\n</code></pre> <p>The write-the tests command will generate test cases for all the functions in the specified directory that are not already tested. By default the tests will be printed to the console, you can use the <code>--save</code> flag to write the tests to the <code>--out</code> directory (default is <code>tests</code>).</p> <pre><code>write-the tests --save write_the\n</code></pre>"},{"location":"reference/cli/","title":"Cli","text":""},{"location":"reference/cli/#write_the.cli.tasks.async_cli_task","title":"<code>async_cli_task(file, nodes, update, force, save, context, background, pretty, batch, print_status, progress, model='gpt-3.5-turbo-instruct')</code>  <code>async</code>","text":"<p>Executes a task asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The file to process.</p> required <code>nodes</code> <code>List</code> <p>The nodes to process.</p> required <code>update</code> <code>bool</code> <p>Whether to update the task.</p> required <code>force</code> <code>bool</code> <p>Whether to force the task.</p> required <code>save</code> <code>bool</code> <p>Whether to save the task.</p> required <code>context</code> <code>bool</code> <p>Whether to include context.</p> required <code>background</code> <code>bool</code> <p>Whether to run the task in the background.</p> required <code>pretty</code> <code>bool</code> <p>Whether to format the output.</p> required <code>batch</code> <code>bool</code> <p>Whether to run in batch mode.</p> required <code>print_status</code> <code>bool</code> <p>Whether to print the status.</p> required <code>progress</code> <code>Progress</code> <p>The progress object.</p> required <code>model</code> <code>str</code> <p>The model to use for the task. Defaults to \"gpt-3.5-turbo-instruct\".</p> <code>'gpt-3.5-turbo-instruct'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Side Effects <p>Writes to the file if save is True. Prints the pass/fail status if print_status is True. Pretty prints the result if pretty is True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await async_cli_task(file, nodes, update, force, save, context, background, pretty, batch, print_status, progress)\nNone\n</code></pre> Source code in <code>write_the/cli/tasks.py</code> <pre><code>async def async_cli_task(\nfile: Path,\nnodes: List,\nupdate: bool,\nforce: bool,\nsave: bool,\ncontext: bool,\nbackground: bool,\npretty: bool,\nbatch: bool,\nprint_status: bool,\nprogress: Progress,\nmodel: str = \"gpt-3.5-turbo-instruct\",\n) -&gt; None:\n\"\"\"\n    Executes a task asynchronously.\n    Args:\n      file (Path): The file to process.\n      nodes (List): The nodes to process.\n      update (bool): Whether to update the task.\n      force (bool): Whether to force the task.\n      save (bool): Whether to save the task.\n      context (bool): Whether to include context.\n      background (bool): Whether to run the task in the background.\n      pretty (bool): Whether to format the output.\n      batch (bool): Whether to run in batch mode.\n      print_status (bool): Whether to print the status.\n      progress (Progress): The progress object.\n      model (str, optional): The model to use for the task. Defaults to \"gpt-3.5-turbo-instruct\".\n    Returns:\n      None\n    Side Effects:\n      Writes to the file if save is True.\n      Prints the pass/fail status if print_status is True.\n      Pretty prints the result if pretty is True.\n    Examples:\n      &gt;&gt;&gt; await async_cli_task(file, nodes, update, force, save, context, background, pretty, batch, print_status, progress)\n      None\n    \"\"\"\ntask_id = progress.add_task(description=f\"{file}\", total=None)\nfailed = False\nskipped = False\nsource_code = load_source_code(file=file)\nif pretty:\nsource_code = format_source_code(source_code)\ntree = create_tree(source_code)\nmax_batch_size = None\nmsg = \"\"\nif batch:\nmax_batch_size = 1\ntry:\nresult = await write_the_docs(\ntree,\nnode_names=nodes,\nupdate=update,\nforce=force,\nsave=save,\ncontext=context,\nbackground=background,\npretty=pretty,\nmax_batch_size=max_batch_size,\nmodel=model,\n)\nexcept ValueError as e:\nmsg = f\" - {e}\"\nfailed = True\nexcept InvalidRequestError as e:\nmsg = f\" - {e}\"\nfailed = True\nexcept FileSkippedError as e:\nmsg = f\" - {e}\"\nskipped = True\nprogress.remove_task(task_id)\nprogress.refresh()\nif print_status or save or failed or skipped:\nif skipped:\nicon = \"\u23ed\ufe0f\"\ncolour = \"yellow\"\nelif failed:\nicon = \"\u274c\"\ncolour = \"red\" \nelse:\nicon = \"\u2705\"\ncolour = \"green\"\nprogress.print(\nf\"[not underline]{icon} [/not underline][underline]{file}[/underline]{msg}\",\nstyle=f\"bold {colour}\",\n)\nif failed or skipped:\nreturn None\nif save:\nwith open(file, \"w\") as f:\nf.writelines(result)\nreturn None\nif pretty:\nsyntax = Syntax(result, \"python\")\nprogress.print(syntax)\nelse:\nprogress.print(result, highlight=False, markup=False)\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.callback","title":"<code>callback(version=typer.Option(None, '-v', '--version', help='Show the pipeline version.', is_eager=True, callback=_print_version, show_default=False))</code>","text":"<p>AI-powered Code Generation and Refactoring Tool</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.callback(context_settings={\"help_option_names\": [\"-h\", \"--help\"]})\ndef callback(\nversion: Optional[bool] = typer.Option(\nNone,\n\"-v\",\n\"--version\",\nhelp=\"Show the pipeline version.\",\nis_eager=True,\ncallback=_print_version,\nshow_default=False,\n)\n):\n\"\"\"\n    AI-powered Code Generation and Refactoring Tool\n    \"\"\"\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.convert","title":"<code>convert(in_file=typer.Argument(..., help='Path to the code file.', dir_okay=False, exists=True), out_file=typer.Argument(None, help='File to save the output to.', dir_okay=False), input_format=typer.Option(None, '--input-format', '-i', help='The input format of the file.'), output_format=typer.Option(None, '--output-format', '-o', help='The format to convert the file to.'), force=typer.Option(False, '--force', '-f', help='Generate output file even if they already exist.'), pretty=typer.Option(False, '--pretty/--plain', '-p', help='Syntax highlight the output.'), model=typer.Option(None, '--model', '-m', help='The model to use for generating the tests.', callback=_get_model_callback))</code>  <code>async</code>","text":"<p>Convert input file to a different format.</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.async_command()\nasync def convert(\nin_file: Path = typer.Argument(..., help=\"Path to the code file.\", dir_okay=False, exists=True),\nout_file: Optional[Path] = typer.Argument(\nNone,\nhelp=\"File to save the output to.\",\ndir_okay=False,\n),\ninput_format: str = typer.Option(\nNone,\n\"--input-format\",\n\"-i\",\nhelp=\"The input format of the file.\",\n),\noutput_format: str = typer.Option(\nNone,\n\"--output-format\",\n\"-o\",\nhelp=\"The format to convert the file to.\",\n),\nforce: bool = typer.Option(\nFalse, \"--force\", \"-f\", help=\"Generate output file even if they already exist.\"\n),\npretty: bool = typer.Option(\nFalse, \"--pretty/--plain\", \"-p\", help=\"Syntax highlight the output.\"\n),\nmodel: str = typer.Option(\nNone,\n\"--model\",\n\"-m\",\nhelp=\"The model to use for generating the tests.\",\ncallback=_get_model_callback,\n),\n):\n\"\"\"\n    Convert input file to a different format.\n    \"\"\"\nif not force and (out_file and out_file.exists()):\ntyper.secho(\"Output file exists!\", fg=\"red\")\nreturn typer.Exit(1)\nif not input_format:\ninput_format = in_file.suffix\nif not output_format and not out_file:\ntyper.secho(\"Output format required!\", fg=\"red\")\nreturn typer.Exit(1)\nif not output_format:\noutput_format = out_file.suffix\nwith Progress(\nSpinnerColumn(),\nTextColumn(\"[progress.description]{task.description}\"),\ntransient=True,\n) as progress:\nfailed = False\nprogress.add_task(description=f\"converting {in_file.name} to {output_format}\", total=None)\ntry:\nresult = await write_the_converters(\nin_file,\ninput_format=input_format,\noutput_format=output_format,\nmodel=model\n)\nexcept InvalidInput:\nfailed = True\nresult = \"\"\nprogress.stop()\nif out_file or failed:\nicon = \"\u274c\" if failed else \"\u2705\"\ncolour = \"red\" if failed else \"green\"\ntyper.secho(f\"{icon} {in_file} -&gt; {out_file}\", fg=colour)\nif failed:\nreturn typer.Exit(1)\nif out_file:\nwith open(out_file, \"w\") as f:\nf.writelines(result)\nelif pretty:\nsyntax = Syntax(result, \"python\")\nconsole = Console()\nconsole.print(syntax)\nelse:\ntyper.echo(result)\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.docs","title":"<code>docs(file=typer.Argument(..., help='Path to the code file/folder.'), nodes=typer.Option(None, '--node', '-n', help='Generate docs for specific nodes (functions and classes).'), save=typer.Option(False, '--save/--print', '-s', help='Save the docstrings to file or print to stdout.'), pretty=typer.Option(False, '--pretty/--plain', '-p', help='Syntax highlight and format the output.'), context=typer.Option(False, '--context/--no-context', '-c', help='Send context (other nodes) with nodes.'), background=typer.Option(True, '--background/--no-background', '-g', help='Send background (other code) with nodes.'), force=typer.Option(False, '--force/--no-force', '-f', help='Generate docstings even if they already exist.'), update=typer.Option(False, '--update/--no-update', '-u', help='Update the existing docstrings.'), batch=typer.Option(False, '--batch/--no-batch', '-b', help='Send each node as a separate request.'), model=typer.Option(None, '--model', '-m', help='The model to use for generating the docstrings.', callback=_get_model_callback))</code>  <code>async</code>","text":"<p>Document your code with AI.</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.async_command()\nasync def docs(\nfile: List[Path] = typer.Argument(..., help=\"Path to the code file/folder.\"),\nnodes: List[str] = typer.Option(\nNone,\n\"--node\",\n\"-n\",\nhelp=\"Generate docs for specific nodes (functions and classes).\",\n),\nsave: bool = typer.Option(\nFalse,\n\"--save/--print\",\n\"-s\",\nhelp=\"Save the docstrings to file or print to stdout.\",\n),\npretty: bool = typer.Option(\nFalse, \"--pretty/--plain\", \"-p\", help=\"Syntax highlight and format the output.\"\n),\ncontext: bool = typer.Option(\nFalse,\n\"--context/--no-context\",\n\"-c\",\nhelp=\"Send context (other nodes) with nodes.\",\n),\nbackground: bool = typer.Option(\nTrue,\n\"--background/--no-background\",\n\"-g\",\nhelp=\"Send background (other code) with nodes.\",\n),\nforce: bool = typer.Option(\nFalse,\n\"--force/--no-force\",\n\"-f\",\nhelp=\"Generate docstings even if they already exist.\",\n),\nupdate: bool = typer.Option(\nFalse,\n\"--update/--no-update\",\n\"-u\",\nhelp=\"Update the existing docstrings.\",\n),\nbatch: bool = typer.Option(\nFalse, \"--batch/--no-batch\", \"-b\", help=\"Send each node as a separate request.\"\n),\nmodel: str = typer.Option(\nNone,\n\"--model\",\n\"-m\",\nhelp=\"The model to use for generating the docstrings.\",\ncallback=_get_model_callback,\n),\n):\n\"\"\"\n    Document your code with AI.\n    \"\"\"\nfiles = []\nfor f in file:\nif f.is_dir():\nfiles.extend(list_python_files(f))\nelse:\nif f.suffix != \".py\":\nraise typer.BadParameter(\"File must be a .py file or a directory.\")\nfiles.append(f)\nwith Progress(\nSpinnerColumn(),\nTextColumn(\"{task.description}\"),\ntransient=True,\nauto_refresh=True,\n) as progress:\ntasks = []\nprint_status = len(files) &gt; 1\nfor file in files:\ntasks.append(\nasync_cli_task(\nfile,\nnodes=nodes,\nforce=force,\nupdate=update,\nsave=save,\ncontext=context,\nbackground=background,\npretty=pretty,\nbatch=batch,\nprint_status=print_status,\nprogress=progress,\nmodel=model,\n)\n)\nawait gather(*tasks)\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.mkdocs","title":"<code>mkdocs(code_dir=typer.Argument(..., help='Path to the projects code. Uses docstings to build API reference.', file_okay=False), readme=typer.Option(None, help='Path to projects README (used to create index.md).', dir_okay=False), out_dir=typer.Option(Path('.'), '--out', '-o', help='Path to save output (docs/ and yaml). Defaults to current directory.'))</code>","text":"<p>Generate a mkdocs website for a project including the API reference.</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.command()\ndef mkdocs(\ncode_dir: Path = typer.Argument(\n...,\nhelp=\"Path to the projects code. Uses docstings to build API reference.\",\nfile_okay=False,\n),\nreadme: Optional[Path] = typer.Option(\nNone, help=\"Path to projects README (used to create index.md).\", dir_okay=False\n),\nout_dir: Path = typer.Option(\nPath(\".\"),\n\"--out\",\n\"-o\",\nhelp=\"Path to save output (docs/ and yaml). Defaults to current directory.\",\n),\n):\n\"\"\"\n    Generate a mkdocs website for a project including the API reference.\n    \"\"\"\nwrite_the_mkdocs(code_dir=code_dir, readme=readme, out_dir=out_dir)\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.model","title":"<code>model(desired_model=typer.Argument(None, help='Set the default model.'), list=typer.Option(False, '--list', '-l', help='List all available models.'))</code>","text":"<p>View or set the default model.</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.command()\ndef model(\ndesired_model: Optional[str] = typer.Argument(\nNone,\nhelp=\"Set the default model.\",\n),\nlist: bool = typer.Option(\nFalse,\n\"--list\",\n\"-l\",\nhelp=\"List all available models.\",\n),\n):\n\"\"\"\n    View or set the default model.\n    \"\"\"\ndefault_model = get_default_model()\nif list:\nfrom rich import table, print\ntable_ = table.Table()\ntable_.add_column(\"Name\", justify=\"left\", style=\"cyan\")\ntable_.add_column(\"Context\", justify=\"left\", style=\"magenta\")\ntable_.add_column(\"Default\", justify=\"left\", style=\"green\")\nfor name, model in models.items():\nif name == default_model:\ntable_.add_row(name, f\"{model['context_window']}\", \"\u2705\")\nelse:\ntable_.add_row(name, f\"{model['context_window']}\", \"\")\nprint(table_)\nreturn typer.Exit(0)\nif desired_model:\nif desired_model not in models:\ntyper.secho(f\"Model '{desired_model}' not found!\", fg=\"red\")\nreturn typer.Exit(1)\nset_default_model(desired_model)\ntyper.echo(f\"Default model: {desired_model}\")\nreturn typer.Exit(0)\ntyper.echo(default_model)\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.optimise","title":"<code>optimise()</code>","text":"<p>Optimise your code with AI (not implemented yet).</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.command()\ndef optimise():\n\"\"\"Optimise your code with AI (not implemented yet).\"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.refactor","title":"<code>refactor()</code>","text":"<p>Refactor your code with AI (not implemented yet).</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.command()\ndef refactor():\n\"\"\"Refactor your code with AI (not implemented yet).\"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.tests","title":"<code>tests(file=typer.Argument(..., help='Path to the code file/folder.'), tests_dir=typer.Option('tests', '--out', '-o', help='Path to save the docs.'), save=typer.Option(False, '--save/--print', '-s', help='Save the tests to the tests directory or print to stdout.'), pretty=typer.Option(False, '--pretty/--plain', '-p', help='Syntax highlight the output.'), group=typer.Option(False, '--group/--flat', '-g', help='Group the tests into folder or keep them flat.'), force=typer.Option(False, '--force', '-f', help='Generate tests even if they already exist.'), empty=typer.Option(False, '--empty', '-e', help='Save empty files if a test creation fails. This will prevent write-the from regenerating failed test creations.'), model=typer.Option(None, '--model', '-m', help='The model to use for generating the tests.', callback=_get_model_callback))</code>  <code>async</code>","text":"<p>Generate tests for your code.</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.async_command()\nasync def tests(\nfile: Path = typer.Argument(..., help=\"Path to the code file/folder.\"),\ntests_dir: Path = typer.Option(\n\"tests\", \"--out\", \"-o\", help=\"Path to save the docs.\"\n),\nsave: bool = typer.Option(\nFalse,\n\"--save/--print\",\n\"-s\",\nhelp=\"Save the tests to the tests directory or print to stdout.\",\n),\npretty: bool = typer.Option(\nFalse, \"--pretty/--plain\", \"-p\", help=\"Syntax highlight the output.\"\n),\ngroup: bool = typer.Option(\nFalse,\n\"--group/--flat\",\n\"-g\",\nhelp=\"Group the tests into folder or keep them flat.\",\n),\nforce: bool = typer.Option(\nFalse, \"--force\", \"-f\", help=\"Generate tests even if they already exist.\"\n),\nempty: bool = typer.Option(\nFalse,\n\"--empty\",\n\"-e\",\nhelp=\"Save empty files if a test creation fails. This will prevent write-the from regenerating failed test creations.\",\n),\nmodel: str = typer.Option(\nNone,\n\"--model\",\n\"-m\",\nhelp=\"The model to use for generating the tests.\",\ncallback=_get_model_callback,\n),\n):\n\"\"\"\n    Generate tests for your code.\n    \"\"\"\ncurrent_tests = list_python_files(tests_dir)\nif file.is_dir():\nfiles = list_python_files(file)\nelse:\nif file.suffix != \".py\":\nraise typer.BadParameter(\"File must be a .py file or a directory.\")\nfiles = [file]\nfor file in files:\nif file.stem.startswith(\"_\"):\ncontinue\nparts = list(file.parts[1:-1])\nparts = [\"test\"] + parts\ntest_file = f\"{'_'.join(parts)}_{file.stem}.py\"\nif group:\nparts.append(test_file)\ntest_file = Path(os.path.join(*parts))\ntest_file_path = tests_dir / test_file\nif (\ntest_file_path.exists()\nand (not force and save)\nor (test_file in current_tests)\n):\ncontinue\nwith Progress(\nSpinnerColumn(),\nTextColumn(\"[progress.description]{task.description}\"),\ntransient=True,\n) as progress:\nfailed = False\nprogress.add_task(description=f\"{file}\", total=None)\ntry:\nresult = await write_the_tests(file, model=model)\nexcept InvalidInput:\nfailed = True\nresult = \"\"\nprogress.stop()\nif len(files) &gt; 1 or save or failed:\nicon = \"\u274c\" if failed else \"\u2705\"\ncolour = \"red\" if failed else \"green\"\ntyper.secho(f\"{icon} {file}\", fg=colour)\nif failed and not empty:\ncontinue\nif save:\n# create test file\ntests_dir.mkdir(exist_ok=True)\ntest_file_path.parent.mkdir(exist_ok=True, parents=True)\nwith open(test_file_path, \"w\") as f:\nf.writelines(result)\nelif pretty:\nsyntax = Syntax(result, \"python\")\nconsole = Console()\nconsole.print(syntax)\nelse:\ntyper.echo(result)\n</code></pre>"},{"location":"reference/commands/","title":"Commands","text":""},{"location":"reference/commands/#write_the.commands.tests.tests.write_the_tests","title":"<code>write_the_tests(filename, model='gpt-3.5-turbo-instruct')</code>  <code>async</code>","text":"<p>Formats and runs the tests for a given file using a specified model.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>The path to the file to be tested.</p> required <code>model</code> <code>str</code> <p>The model to use for the generation. Defaults to \"gpt-3.5-turbo-instruct\".</p> <code>'gpt-3.5-turbo-instruct'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted and tested code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; write_the_tests(Path(\"test.py\"), \"gpt-3.5-turbo-instruct\")\n\"Formatted and tested code\"\n</code></pre> Note <p>This function is asynchronous and should be awaited when called.</p> Source code in <code>write_the/commands/tests/tests.py</code> <pre><code>async def write_the_tests(filename: Path, model=\"gpt-3.5-turbo-instruct\") -&gt; str:\n\"\"\"\n    Formats and runs the tests for a given file using a specified model.\n    Args:\n      filename (Path): The path to the file to be tested.\n      model (str): The model to use for the generation. Defaults to \"gpt-3.5-turbo-instruct\".\n    Returns:\n      str: The formatted and tested code.\n    Examples:\n      &gt;&gt;&gt; write_the_tests(Path(\"test.py\"), \"gpt-3.5-turbo-instruct\")\n      \"Formatted and tested code\"\n    Note:\n      This function is asynchronous and should be awaited when called.\n    \"\"\"\nwith open(filename, \"r\") as file:\nsource_code = file.read()\nsource_code = format_str(source_code, mode=FileMode())\nllm = LLM(write_tests_for_file_prompt, model_name=model)\nresult = await llm.run(code=source_code, path=filename)\ncode = (\nresult.strip()\n.lstrip(\"Test Code:\\n```python\")\n.lstrip(\"```python\")\n.lstrip(\"```\")\n.rstrip(\"```\")\n)\nreturn format_str(code, mode=FileMode())\n</code></pre>"},{"location":"reference/commands/#write_the.commands.converters.converters.write_the_converters","title":"<code>write_the_converters(filename, input_format, output_format, model='gpt-3.5-turbo-instruct')</code>  <code>async</code>","text":"<p>Formats and runs the tests for a given file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>The path to the file to be tested.</p> required <code>input_format</code> <code>str</code> <p>The input format of the file.</p> required <code>output_format</code> <code>str</code> <p>The format to convert the file to.</p> required <code>model</code> <code>str</code> <p>The model to use for conversion. Defaults to \"gpt-3.5-turbo-instruct\".</p> <code>'gpt-3.5-turbo-instruct'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The converted output.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; write_the_converters(Path(\".travis.yml\"), input_format=\"Travis CI\", output_format=\"Github Actions\", model=\"gpt-3.5-turbo-instruct\")\n\"The converted output\"\n</code></pre> Source code in <code>write_the/commands/converters/converters.py</code> <pre><code>async def write_the_converters(filename: Path, input_format: str, output_format: str, model: str = \"gpt-3.5-turbo-instruct\") -&gt; str:\n\"\"\"\n    Formats and runs the tests for a given file.\n    Args:\n      filename (Path): The path to the file to be tested.\n      input_format (str): The input format of the file.\n      output_format (str): The format to convert the file to.\n      model (str, optional): The model to use for conversion. Defaults to \"gpt-3.5-turbo-instruct\".\n    Returns:\n      str: The converted output.\n    Examples:\n      &gt;&gt;&gt; write_the_converters(Path(\".travis.yml\"), input_format=\"Travis CI\", output_format=\"Github Actions\", model=\"gpt-3.5-turbo-instruct\")\n      \"The converted output\"\n    \"\"\"\nwith open(filename, \"r\") as file:\nsource_text = file.read()\nllm = LLM(write_converters_for_file_prompt, model_name=model)\nresult = await llm.run(code=source_text, input_format=input_format, output_format=output_format)\nformatted_text = result.strip()\nif formatted_text.endswith('```') and not source_text.endswith('```'):\n# strip the last line of the code block if the source text didn't end with a code block\nformatted_text = formatted_text[: formatted_text.rfind(\"\\n\")]\nif formatted_text.startswith('```') and not source_text.startswith('```'):\n# strip the first line of the code block if the source text didn't start with a code block\nformatted_text = formatted_text[formatted_text.find(\"\\n\") + 1 :]\nreturn formatted_text.strip()\n</code></pre>"},{"location":"reference/commands/#write_the.commands.docs.docs.write_the_docs","title":"<code>write_the_docs(tree, node_names=[], update=False, force=False, save=False, context=False, background=True, pretty=False, max_batch_size=False, model='gpt-3.5-turbo-instruct')</code>  <code>async</code>","text":"<p>Generates docstrings for a given tree of nodes using a specified model.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.Module</code> <p>The tree of nodes to write docs for.</p> required <code>node_names</code> <code>list</code> <p>The list of nodes names to write docs for. Defaults to an empty list.</p> <code>[]</code> <code>update</code> <code>bool</code> <p>Whether to update existing docstrings. Defaults to False.</p> <code>False</code> <code>force</code> <code>bool</code> <p>Whether to force writing of docs. Defaults to False.</p> <code>False</code> <code>save</code> <code>bool</code> <p>Whether to save the docs. Defaults to False.</p> <code>False</code> <code>context</code> <code>bool</code> <p>Whether to include context nodes. Defaults to False.</p> <code>False</code> <code>background</code> <code>bool</code> <p>Whether to run the process in the background. Defaults to True.</p> <code>True</code> <code>pretty</code> <code>bool</code> <p>Whether to format the code. Defaults to False.</p> <code>False</code> <code>max_batch_size</code> <code>bool</code> <p>Max number of nodes in each batch. Defaults to False.</p> <code>False</code> <code>model</code> <code>str</code> <p>The model to use for the generation. Defaults to \"gpt-3.5-turbo-instruct\".</p> <code>'gpt-3.5-turbo-instruct'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The source code with the generated docstrings.</p> <p>Raises:</p> Type Description <code>FileSkippedError</code> <p>If no nodes are found.</p> Notes <p>If <code>node_names</code> is provided, <code>force</code> is set to <code>True</code> and <code>context</code> is set to <code>False</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; write_the_docs(tree, model=\"gpt-3.5-turbo-instruct\")\n\"def add(a, b):\n    \"\"\"Sums 2 numbers.\n    Args:\n        a (int): The first number to add.\n        b (int): The second number to add.\n    Returns:\n        int: The sum of `a` and `b`.\n    \"\"\"\n    return a + b\"\n</code></pre> Source code in <code>write_the/commands/docs/docs.py</code> <pre><code>async def write_the_docs(\ntree: cst.Module,\nnode_names=[],\nupdate=False,\nforce=False,\nsave=False,\ncontext=False,\nbackground=True,\npretty=False,\nmax_batch_size=False,\nmodel=\"gpt-3.5-turbo-instruct\",\n) -&gt; str:\n\"\"\"\n    Generates docstrings for a given tree of nodes using a specified model.\n    Args:\n      tree (cst.Module): The tree of nodes to write docs for.\n      node_names (list, optional): The list of nodes names to write docs for. Defaults to an empty list.\n      update (bool, optional): Whether to update existing docstrings. Defaults to False.\n      force (bool, optional): Whether to force writing of docs. Defaults to False.\n      save (bool, optional): Whether to save the docs. Defaults to False.\n      context (bool, optional): Whether to include context nodes. Defaults to False.\n      background (bool, optional): Whether to run the process in the background. Defaults to True.\n      pretty (bool, optional): Whether to format the code. Defaults to False.\n      max_batch_size (bool, optional): Max number of nodes in each batch. Defaults to False.\n      model (str, optional): The model to use for the generation. Defaults to \"gpt-3.5-turbo-instruct\".\n    Returns:\n      str: The source code with the generated docstrings.\n    Raises:\n      FileSkippedError: If no nodes are found.\n    Notes:\n      If `node_names` is provided, `force` is set to `True` and `context` is set to `False`.\n    Examples:\n      &gt;&gt;&gt; write_the_docs(tree, model=\"gpt-3.5-turbo-instruct\")\n      \"def add(a, b):\n          \\\"\\\"\\\"Sums 2 numbers.\n          Args:\n              a (int): The first number to add.\n              b (int): The second number to add.\n          Returns:\n              int: The sum of `a` and `b`.\n          \\\"\\\"\\\"\n          return a + b\"\n    \"\"\"\nextract_specific_nodes = False\nif node_names:\nextract_specific_nodes = True\nforce = True\nelse:\nnode_names = get_node_names(tree, force=force, update=update)\nif not node_names:\nraise FileSkippedError(\"No nodes found, skipping file...\")\nif update:\nremove_docstrings = False\nllm = LLM(update_docstrings_for_nodes_prompt, model_name=model)\nelse:\nremove_docstrings = True\nllm = LLM(write_docstrings_for_nodes_prompt, model_name=model)\nbatches = create_batches(\ntree=tree,\nnode_names=node_names,\nmax_tokens=llm.max_tokens,\nprompt_size=llm.prompt_size,\nresponse_size_per_node=250,  # a guess... TODO: smarter\nmax_batch_size=max_batch_size,\nsend_background_context=background,\nsend_node_context=context,\nremove_docstrings=remove_docstrings\n)\npromises = []\nnode_names_list = []\nfor batch in batches:\nnode_names = batch.node_names\ncode = batch.code\npromises.append((llm.run(code=code, nodes=node_names)))\nnode_names_list.append(node_names)\n# Can i yield here so batches can be logged?\nresults = await asyncio.gather(*promises)\ndocstring_dict = {}\nfor node_names, result in zip(node_names_list, results):\ndocstring_dict.update(extract_block(result, node_names))\nmodified_tree = add_docstrings_to_tree(tree, docstring_dict, force=force or update)\nif not save and extract_specific_nodes:\nextracted_nodes = extract_nodes_from_tree(modified_tree, node_names)\nmodified_tree = nodes_to_tree(extracted_nodes)\nif pretty:\nreturn format_str(modified_tree.code, mode=FileMode())\nreturn modified_tree.code\n</code></pre>"},{"location":"reference/commands/#write_the.commands.docs.utils.process_nodes","title":"<code>process_nodes(tree, nodes, context, extract_specific_nodes)</code>","text":"<p>Processes a tree of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.Module</code> <p>The tree of nodes to process.</p> required <code>nodes</code> <code>list</code> <p>The list of nodes to process.</p> required <code>context</code> <code>bool</code> <p>Whether to include context nodes.</p> required <code>extract_specific_nodes</code> <code>bool</code> <p>Whether to extract specific nodes.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The processed tree as a string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; process_nodes(tree, nodes, context, extract_specific_nodes)\n\"Processed tree as a string\"\n</code></pre> Source code in <code>write_the/commands/docs/utils.py</code> <pre><code>def process_nodes(tree: cst.Module, nodes, context, extract_specific_nodes) -&gt; str:\n\"\"\"\n    Processes a tree of nodes.\n    Args:\n      tree (cst.Module): The tree of nodes to process.\n      nodes (list): The list of nodes to process.\n      context (bool): Whether to include context nodes.\n      extract_specific_nodes (bool): Whether to extract specific nodes.\n    Returns:\n      str: The processed tree as a string.\n    Examples:\n      &gt;&gt;&gt; process_nodes(tree, nodes, context, extract_specific_nodes)\n      \"Processed tree as a string\"\n    \"\"\"\nif not context:\nif extract_specific_nodes:\nextracted_nodes = extract_nodes_from_tree(tree, nodes)\nprocessed_tree = nodes_to_tree(extracted_nodes)\nelse:\nall_nodes = get_node_names(tree, True)\nnodes_to_remove = [n for n in all_nodes if n not in nodes]\nprocessed_tree = remove_nodes_from_tree(tree, nodes_to_remove)\ncode = processed_tree.code\nelse:\ncode = tree.code\nreturn code\n</code></pre>"},{"location":"reference/commands/#write_the.commands.mkdocs.mkdocs.write_the_mkdocs","title":"<code>write_the_mkdocs(code_dir, readme=None, out_dir=Path('.'), project_name=None)</code>","text":"<p>Generates a mkdocs project from a directory of python files.</p> <p>Parameters:</p> Name Type Description Default <code>code_dir</code> <code>Path</code> <p>The directory containing the python files.</p> required <code>readme</code> <code>Path</code> <p>The readme file to include in the project. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>Path</code> <p>The directory to write the project to. Defaults to the current directory.</p> <code>Path('.')</code> <code>project_name</code> <code>str</code> <p>The name of the project. Defaults to the name of the code_dir.</p> <code>None</code> Notes <p>If readme is not provided, the project will not have a home page. If project_name is not provided, the project will be named after the code_dir.</p> Side Effects <p>Creates a mkdocs project in the out_dir. Creates a .github/workflows/mkdocs.yml file in the out_dir.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>write_the/commands/mkdocs/mkdocs.py</code> <pre><code>def write_the_mkdocs(\ncode_dir: Path, readme: Path = None, out_dir: Path = Path(\".\"), project_name=None\n):\n\"\"\"\n    Generates a mkdocs project from a directory of python files.\n    Args:\n      code_dir (Path): The directory containing the python files.\n      readme (Path, optional): The readme file to include in the project. Defaults to None.\n      out_dir (Path, optional): The directory to write the project to. Defaults to the current directory.\n      project_name (str, optional): The name of the project. Defaults to the name of the code_dir.\n    Notes:\n      If readme is not provided, the project will not have a home page.\n      If project_name is not provided, the project will be named after the code_dir.\n    Side Effects:\n      Creates a mkdocs project in the out_dir.\n      Creates a .github/workflows/mkdocs.yml file in the out_dir.\n    Returns:\n      None\n    \"\"\"\nfiles = list_python_files(code_dir)\ngroups = [path.stem for path in code_dir.glob(\"*\") if not path.stem.startswith(\"_\")]\nif not project_name:\nproject_name = code_dir.name\nmkdocs = mkdocs_template.format(project_name=project_name)\nreferences = defaultdict(list)\nfor file in files:\nif file.name.startswith(\"_\"):\ncontinue\nkey = \"index\"\nfor group in groups:\nif f\"{code_dir.name}/{group}/\" in str(\nfile\n) or f\"{code_dir.name}/{group}.\" in str(file):\nkey = group\nbreak\nmodule = str(file).rsplit(\".py\")[0]\nif sys.platform.startswith(\"win32\") or sys.platform.startswith(\"cygwin\"):\nsplitter = \"\\\\\"\nelse:\nsplitter = \"/\"\nmodule = module.replace(splitter, \".\")\nreferences[key].append(f\"::: {module}\")\ndocs_dir = out_dir / \"docs\"\nreference_path = docs_dir / \"reference\"\nreference_path.mkdir(parents=True, exist_ok=True)\nfor doc in references:\nwith open(f\"{reference_path}/{doc}.md\", \"w\") as f:\nfor ref in references[doc]:\nf.write(ref + \"\\n\\n\")\nif readme:\nindex_text = f\"---\\ntitle: Home\\n---\\n{readme.read_text()}\"\n(docs_dir / \"index.md\").write_text(index_text)\nif not (out_dir / \"mkdocs.yml\").exists():\n(out_dir / \"mkdocs.yml\").write_text(mkdocs)\naction_path = out_dir / \".github\" / \"workflows\" / \"mkdocs.yml\"\nif not action_path.exists():\naction_path.parent.mkdir(parents=True, exist_ok=True)\naction_path.write_text(action_template)\n</code></pre>"},{"location":"reference/cst/","title":"Cst","text":""},{"location":"reference/cst/#write_the.cst.function_and_class_collector.FunctionAndClassCollector","title":"<code>FunctionAndClassCollector</code>","text":"<p>             Bases: <code>cst.CSTVisitor</code></p> <p>A CSTVisitor that collects the names of functions and classes from a CST tree.</p> Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>class FunctionAndClassCollector(cst.CSTVisitor):\n\"\"\"\n    A CSTVisitor that collects the names of functions and classes from a CST tree.\n    \"\"\"\ndef __init__(self, force, update=False):\n\"\"\"\n        Initializes the FunctionAndClassCollector.\n        Args:\n          force (bool): Whether to force the collection of functions and classes even if they have docstrings.\n          update (bool): Whether to update the collection of functions and classes if they have docstrings.\n        \"\"\"\nself.functions = []\nself.classes = []\nself.force = force\nself.update = update\nself.current_class = None\ndef visit_FunctionDef(self, node: cst.FunctionDef) -&gt; None:\n\"\"\"\n        Visits a FunctionDef node and adds its name to the list of functions if it does not have a docstring or if `force` or `update` is `True`.\n        Args:\n          node (cst.FunctionDef): The FunctionDef node to visit.\n        \"\"\"\nname = (\nf\"{self.current_class}.{node.name.value}\"\nif self.current_class\nelse node.name.value\n)\nif self.force:\nself.functions.append(name)\nelif has_docstring(node) and self.update:\nself.functions.append(name)\nelif not has_docstring(node) and not self.update:\nself.functions.append(name)\ndef visit_ClassDef(self, node: cst.ClassDef) -&gt; None:\n\"\"\"\n        Visits a ClassDef node and adds its name to the list of classes if it does not have a docstring or if `force` or `update` is `True`. Also sets the current class name for nested function collection.\n        Args:\n          node (cst.ClassDef): The ClassDef node to visit.\n        \"\"\"\nself.current_class = node.name.value\nif self.force:\nself.classes.append(node.name.value)\nelif has_docstring(node) and self.update:\nself.classes.append(node.name.value)\nelif not has_docstring(node) and not self.update:\nself.classes.append(node.name.value)\n# self.visit_ClassDef(node)  # Call the superclass method to continue the visit\ndef leave_ClassDef(self, node: cst.ClassDef) -&gt; None:\n\"\"\"\n        Resets the current class name when leaving a ClassDef node.\n        \"\"\"\nself.current_class = None\n</code></pre>"},{"location":"reference/cst/#write_the.cst.function_and_class_collector.FunctionAndClassCollector.__init__","title":"<code>__init__(force, update=False)</code>","text":"<p>Initializes the FunctionAndClassCollector.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>Whether to force the collection of functions and classes even if they have docstrings.</p> required <code>update</code> <code>bool</code> <p>Whether to update the collection of functions and classes if they have docstrings.</p> <code>False</code> Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>def __init__(self, force, update=False):\n\"\"\"\n    Initializes the FunctionAndClassCollector.\n    Args:\n      force (bool): Whether to force the collection of functions and classes even if they have docstrings.\n      update (bool): Whether to update the collection of functions and classes if they have docstrings.\n    \"\"\"\nself.functions = []\nself.classes = []\nself.force = force\nself.update = update\nself.current_class = None\n</code></pre>"},{"location":"reference/cst/#write_the.cst.function_and_class_collector.FunctionAndClassCollector.leave_ClassDef","title":"<code>leave_ClassDef(node)</code>","text":"<p>Resets the current class name when leaving a ClassDef node.</p> Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>def leave_ClassDef(self, node: cst.ClassDef) -&gt; None:\n\"\"\"\n    Resets the current class name when leaving a ClassDef node.\n    \"\"\"\nself.current_class = None\n</code></pre>"},{"location":"reference/cst/#write_the.cst.function_and_class_collector.FunctionAndClassCollector.visit_ClassDef","title":"<code>visit_ClassDef(node)</code>","text":"<p>Visits a ClassDef node and adds its name to the list of classes if it does not have a docstring or if <code>force</code> or <code>update</code> is <code>True</code>. Also sets the current class name for nested function collection.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.ClassDef</code> <p>The ClassDef node to visit.</p> required Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>def visit_ClassDef(self, node: cst.ClassDef) -&gt; None:\n\"\"\"\n    Visits a ClassDef node and adds its name to the list of classes if it does not have a docstring or if `force` or `update` is `True`. Also sets the current class name for nested function collection.\n    Args:\n      node (cst.ClassDef): The ClassDef node to visit.\n    \"\"\"\nself.current_class = node.name.value\nif self.force:\nself.classes.append(node.name.value)\nelif has_docstring(node) and self.update:\nself.classes.append(node.name.value)\nelif not has_docstring(node) and not self.update:\nself.classes.append(node.name.value)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.function_and_class_collector.FunctionAndClassCollector.visit_FunctionDef","title":"<code>visit_FunctionDef(node)</code>","text":"<p>Visits a FunctionDef node and adds its name to the list of functions if it does not have a docstring or if <code>force</code> or <code>update</code> is <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.FunctionDef</code> <p>The FunctionDef node to visit.</p> required Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>def visit_FunctionDef(self, node: cst.FunctionDef) -&gt; None:\n\"\"\"\n    Visits a FunctionDef node and adds its name to the list of functions if it does not have a docstring or if `force` or `update` is `True`.\n    Args:\n      node (cst.FunctionDef): The FunctionDef node to visit.\n    \"\"\"\nname = (\nf\"{self.current_class}.{node.name.value}\"\nif self.current_class\nelse node.name.value\n)\nif self.force:\nself.functions.append(name)\nelif has_docstring(node) and self.update:\nself.functions.append(name)\nelif not has_docstring(node) and not self.update:\nself.functions.append(name)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.function_and_class_collector.get_node_names","title":"<code>get_node_names(tree, force, update=False)</code>","text":"<p>Gets the names of functions and classes from a CST tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.CSTNode</code> <p>The CST tree to traverse.</p> required <code>force</code> <code>bool</code> <p>Whether to force the collection of functions and classes even if they have docstrings.</p> required <code>update</code> <code>bool</code> <p>Whether to update the collection of functions and classes if they have docstrings. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>list[str]: A list of function and class names.</p> Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>def get_node_names(tree, force, update=False):\n\"\"\"\n    Gets the names of functions and classes from a CST tree.\n    Args:\n      tree (cst.CSTNode): The CST tree to traverse.\n      force (bool): Whether to force the collection of functions and classes even if they have docstrings.\n      update (bool, optional): Whether to update the collection of functions and classes if they have docstrings. Defaults to False.\n    Returns:\n      list[str]: A list of function and class names.\n    \"\"\"\ncollector = FunctionAndClassCollector(force, update)\ntree.visit(collector)\nreturn collector.classes + collector.functions\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_adder.DocstringAdder","title":"<code>DocstringAdder</code>","text":"<p>             Bases: <code>cst.CSTTransformer</code></p> Source code in <code>write_the/cst/docstring_adder.py</code> <pre><code>class DocstringAdder(cst.CSTTransformer):\ndef __init__(self, docstrings, force, indent=\"    \"):\nself.docstrings = docstrings\nself.force = force\nself.indent = indent\nself.current_class = None\ndef leave_FunctionDef(\nself, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n) -&gt; cst.FunctionDef:\n\"\"\"\n        Adds a docstring to a function definition if it doesn't have one.\n        Args:\n          original_node (cst.FunctionDef): The original CST node representing the function definition.\n          updated_node (cst.FunctionDef): The updated CST node representing the function definition.\n        Returns:\n          cst.FunctionDef: The updated CST node with a docstring added if it didn't have one.\n        \"\"\"\nreturn self.add_docstring(updated_node)\ndef visit_ClassDef(self, original_node: cst.ClassDef) -&gt; None:\nself.current_class = original_node.name.value\ndef leave_ClassDef(\nself, original_node: cst.ClassDef, updated_node: cst.ClassDef\n) -&gt; cst.ClassDef:\n\"\"\"\n        Adds a docstring to a class definition if it doesn't have one.\n        Args:\n          original_node (cst.ClassDef): The original CST node representing the class definition.\n          updated_node (cst.ClassDef): The updated CST node representing the class definition.\n        Returns:\n          cst.ClassDef: The updated CST node with a docstring added if it didn't have one.\n        \"\"\"\nself.current_class = None\nupdated_node = self.add_docstring(updated_node)\nreturn updated_node\ndef add_docstring(self, node):\n\"\"\"\n        Adds a docstring to a CST node if it doesn't have one.\n        Args:\n          node (cst.CSTNode): The CST node to add a docstring to.\n        Returns:\n          cst.CSTNode: The updated CST node with a docstring added if it didn't have one.\n        Note:\n          If the node already has a docstring and the force flag is set, the existing docstring is removed before adding the new one.\n        \"\"\"\nkey = (\nf\"{self.current_class}.{node.name.value}\"\nif self.current_class\nelse node.name.value\n)\ndocstring: str = self.docstrings.get(key, None)\nif docstring and (self.force or not has_docstring(node)):\nif self.force and has_docstring(node):\n# Remove existing docstring\nnode = remove_docstring(node)\nescaped_docstring = re.sub(r\"(?&lt;!\\\\)\\\\n\", \"\\\\\\\\\\\\\\\\n\", docstring)\ndedented_docstring = textwrap.dedent(escaped_docstring)\nindent = self.indent\nif self.current_class:\nindent = indent * 2\nindented_docstring = textwrap.indent(dedented_docstring, indent)\nnew_docstring = cst.parse_statement(f'\"\"\"{indented_docstring}{indent}\"\"\"')\nbody = node.body.with_changes(body=(new_docstring, *node.body.body))\nreturn node.with_changes(body=body)\nreturn node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_adder.DocstringAdder.add_docstring","title":"<code>add_docstring(node)</code>","text":"<p>Adds a docstring to a CST node if it doesn't have one.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.CSTNode</code> <p>The CST node to add a docstring to.</p> required <p>Returns:</p> Type Description <p>cst.CSTNode: The updated CST node with a docstring added if it didn't have one.</p> Note <p>If the node already has a docstring and the force flag is set, the existing docstring is removed before adding the new one.</p> Source code in <code>write_the/cst/docstring_adder.py</code> <pre><code>def add_docstring(self, node):\n\"\"\"\n    Adds a docstring to a CST node if it doesn't have one.\n    Args:\n      node (cst.CSTNode): The CST node to add a docstring to.\n    Returns:\n      cst.CSTNode: The updated CST node with a docstring added if it didn't have one.\n    Note:\n      If the node already has a docstring and the force flag is set, the existing docstring is removed before adding the new one.\n    \"\"\"\nkey = (\nf\"{self.current_class}.{node.name.value}\"\nif self.current_class\nelse node.name.value\n)\ndocstring: str = self.docstrings.get(key, None)\nif docstring and (self.force or not has_docstring(node)):\nif self.force and has_docstring(node):\n# Remove existing docstring\nnode = remove_docstring(node)\nescaped_docstring = re.sub(r\"(?&lt;!\\\\)\\\\n\", \"\\\\\\\\\\\\\\\\n\", docstring)\ndedented_docstring = textwrap.dedent(escaped_docstring)\nindent = self.indent\nif self.current_class:\nindent = indent * 2\nindented_docstring = textwrap.indent(dedented_docstring, indent)\nnew_docstring = cst.parse_statement(f'\"\"\"{indented_docstring}{indent}\"\"\"')\nbody = node.body.with_changes(body=(new_docstring, *node.body.body))\nreturn node.with_changes(body=body)\nreturn node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_adder.DocstringAdder.leave_ClassDef","title":"<code>leave_ClassDef(original_node, updated_node)</code>","text":"<p>Adds a docstring to a class definition if it doesn't have one.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.ClassDef</code> <p>The original CST node representing the class definition.</p> required <code>updated_node</code> <code>cst.ClassDef</code> <p>The updated CST node representing the class definition.</p> required <p>Returns:</p> Type Description <code>cst.ClassDef</code> <p>cst.ClassDef: The updated CST node with a docstring added if it didn't have one.</p> Source code in <code>write_the/cst/docstring_adder.py</code> <pre><code>def leave_ClassDef(\nself, original_node: cst.ClassDef, updated_node: cst.ClassDef\n) -&gt; cst.ClassDef:\n\"\"\"\n    Adds a docstring to a class definition if it doesn't have one.\n    Args:\n      original_node (cst.ClassDef): The original CST node representing the class definition.\n      updated_node (cst.ClassDef): The updated CST node representing the class definition.\n    Returns:\n      cst.ClassDef: The updated CST node with a docstring added if it didn't have one.\n    \"\"\"\nself.current_class = None\nupdated_node = self.add_docstring(updated_node)\nreturn updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_adder.DocstringAdder.leave_FunctionDef","title":"<code>leave_FunctionDef(original_node, updated_node)</code>","text":"<p>Adds a docstring to a function definition if it doesn't have one.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.FunctionDef</code> <p>The original CST node representing the function definition.</p> required <code>updated_node</code> <code>cst.FunctionDef</code> <p>The updated CST node representing the function definition.</p> required <p>Returns:</p> Type Description <code>cst.FunctionDef</code> <p>cst.FunctionDef: The updated CST node with a docstring added if it didn't have one.</p> Source code in <code>write_the/cst/docstring_adder.py</code> <pre><code>def leave_FunctionDef(\nself, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n) -&gt; cst.FunctionDef:\n\"\"\"\n    Adds a docstring to a function definition if it doesn't have one.\n    Args:\n      original_node (cst.FunctionDef): The original CST node representing the function definition.\n      updated_node (cst.FunctionDef): The updated CST node representing the function definition.\n    Returns:\n      cst.FunctionDef: The updated CST node with a docstring added if it didn't have one.\n    \"\"\"\nreturn self.add_docstring(updated_node)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_remover.DocstringRemover","title":"<code>DocstringRemover</code>","text":"<p>             Bases: <code>cst.CSTTransformer</code></p> Source code in <code>write_the/cst/docstring_remover.py</code> <pre><code>class DocstringRemover(cst.CSTTransformer):\ndef __init__(self, nodes):\n\"\"\"\n        Initializes the DocstringRemover object.\n        Args:\n          nodes (list): A list of nodes to remove docstrings from.\n        \"\"\"\nself.nodes = nodes\nself.current_class = None\ndef leave_FunctionDef(\nself, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n) -&gt; cst.FunctionDef:\n\"\"\"\n        Removes the docstring from a FunctionDef node if it is in the list of nodes.\n        Args:\n          original_node (cst.FunctionDef): The original FunctionDef node.\n          updated_node (cst.FunctionDef): The updated FunctionDef node.\n        Returns:\n          cst.FunctionDef: The updated FunctionDef node with the docstring removed if it is in the list of nodes.\n        \"\"\"\nname = (\nf\"{self.current_class}.{original_node.name.value}\"\nif self.current_class\nelse original_node.name.value\n)\nif name in self.nodes:\nreturn remove_docstring(updated_node)\nreturn updated_node\ndef visit_ClassDef(self, original_node: cst.ClassDef) -&gt; None:\nself.current_class = original_node.name.value\ndef leave_ClassDef(\nself, original_node: cst.ClassDef, updated_node: cst.ClassDef\n) -&gt; cst.ClassDef:\n\"\"\"\n        Removes the docstring from a ClassDef node if it is in the list of nodes and resets the current_class attribute to None.\n        Args:\n          original_node (cst.ClassDef): The original ClassDef node.\n          updated_node (cst.ClassDef): The updated ClassDef node.\n        Returns:\n          cst.ClassDef: The updated ClassDef node with the docstring removed if it is in the list of nodes.\n        \"\"\"\nself.current_class = None\nif original_node.name.value in self.nodes:\nreturn remove_docstring(updated_node)\nreturn updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_remover.DocstringRemover.__init__","title":"<code>__init__(nodes)</code>","text":"<p>Initializes the DocstringRemover object.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>A list of nodes to remove docstrings from.</p> required Source code in <code>write_the/cst/docstring_remover.py</code> <pre><code>def __init__(self, nodes):\n\"\"\"\n    Initializes the DocstringRemover object.\n    Args:\n      nodes (list): A list of nodes to remove docstrings from.\n    \"\"\"\nself.nodes = nodes\nself.current_class = None\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_remover.DocstringRemover.leave_ClassDef","title":"<code>leave_ClassDef(original_node, updated_node)</code>","text":"<p>Removes the docstring from a ClassDef node if it is in the list of nodes and resets the current_class attribute to None.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.ClassDef</code> <p>The original ClassDef node.</p> required <code>updated_node</code> <code>cst.ClassDef</code> <p>The updated ClassDef node.</p> required <p>Returns:</p> Type Description <code>cst.ClassDef</code> <p>cst.ClassDef: The updated ClassDef node with the docstring removed if it is in the list of nodes.</p> Source code in <code>write_the/cst/docstring_remover.py</code> <pre><code>def leave_ClassDef(\nself, original_node: cst.ClassDef, updated_node: cst.ClassDef\n) -&gt; cst.ClassDef:\n\"\"\"\n    Removes the docstring from a ClassDef node if it is in the list of nodes and resets the current_class attribute to None.\n    Args:\n      original_node (cst.ClassDef): The original ClassDef node.\n      updated_node (cst.ClassDef): The updated ClassDef node.\n    Returns:\n      cst.ClassDef: The updated ClassDef node with the docstring removed if it is in the list of nodes.\n    \"\"\"\nself.current_class = None\nif original_node.name.value in self.nodes:\nreturn remove_docstring(updated_node)\nreturn updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_remover.DocstringRemover.leave_FunctionDef","title":"<code>leave_FunctionDef(original_node, updated_node)</code>","text":"<p>Removes the docstring from a FunctionDef node if it is in the list of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.FunctionDef</code> <p>The original FunctionDef node.</p> required <code>updated_node</code> <code>cst.FunctionDef</code> <p>The updated FunctionDef node.</p> required <p>Returns:</p> Type Description <code>cst.FunctionDef</code> <p>cst.FunctionDef: The updated FunctionDef node with the docstring removed if it is in the list of nodes.</p> Source code in <code>write_the/cst/docstring_remover.py</code> <pre><code>def leave_FunctionDef(\nself, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n) -&gt; cst.FunctionDef:\n\"\"\"\n    Removes the docstring from a FunctionDef node if it is in the list of nodes.\n    Args:\n      original_node (cst.FunctionDef): The original FunctionDef node.\n      updated_node (cst.FunctionDef): The updated FunctionDef node.\n    Returns:\n      cst.FunctionDef: The updated FunctionDef node with the docstring removed if it is in the list of nodes.\n    \"\"\"\nname = (\nf\"{self.current_class}.{original_node.name.value}\"\nif self.current_class\nelse original_node.name.value\n)\nif name in self.nodes:\nreturn remove_docstring(updated_node)\nreturn updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_remover.remove_docstrings_from_tree","title":"<code>remove_docstrings_from_tree(tree, nodes)</code>","text":"<p>Removes the docstrings from a tree of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.CSTNode</code> <p>The tree of nodes to remove the docstrings from.</p> required <code>nodes</code> <code>list</code> <p>A list of nodes to remove docstrings from.</p> required <p>Returns:</p> Type Description <p>cst.CSTNode: The tree of nodes with the docstrings removed.</p> Source code in <code>write_the/cst/docstring_remover.py</code> <pre><code>def remove_docstrings_from_tree(tree, nodes):\n\"\"\"\n    Removes the docstrings from a tree of nodes.\n    Args:\n      tree (cst.CSTNode): The tree of nodes to remove the docstrings from.\n      nodes (list): A list of nodes to remove docstrings from.\n    Returns:\n      cst.CSTNode: The tree of nodes with the docstrings removed.\n    \"\"\"\nremover = DocstringRemover(nodes)\ntree = tree.visit(remover)\nreturn tree\n</code></pre>"},{"location":"reference/cst/#write_the.cst.utils.get_docstring","title":"<code>get_docstring(node)</code>","text":"<p>Retrieves the docstring of a CSTNode if it has one.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.CSTNode</code> <p>The node to check.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the node if it exists, None otherwise.</p> Notes <p>Only retrieves docstrings for FunctionDef and ClassDef nodes.</p> Source code in <code>write_the/cst/utils.py</code> <pre><code>def get_docstring(node: cst.CSTNode) -&gt; Optional[str]:\n\"\"\"\n    Retrieves the docstring of a CSTNode if it has one.\n    Args:\n      node (cst.CSTNode): The node to check.\n    Returns:\n      Optional[str]: The docstring of the node if it exists, None otherwise.\n    Notes:\n      Only retrieves docstrings for FunctionDef and ClassDef nodes.\n    \"\"\"\nif has_docstring(node):\nbody = node.body.body\nstmt = body[0].body[0]\nreturn stmt.value.value\nreturn None\n</code></pre>"},{"location":"reference/cst/#write_the.cst.utils.has_docstring","title":"<code>has_docstring(node)</code>","text":"<p>Checks if a CSTNode has a docstring.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.CSTNode</code> <p>The node to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether or not the node has a docstring.</p> Notes <p>Only checks for docstrings on FunctionDef and ClassDef nodes.</p> Source code in <code>write_the/cst/utils.py</code> <pre><code>def has_docstring(node: cst.CSTNode) -&gt; bool:\n\"\"\"\n    Checks if a CSTNode has a docstring.\n    Args:\n      node (cst.CSTNode): The node to check.\n    Returns:\n      bool: Whether or not the node has a docstring.\n    Notes:\n      Only checks for docstrings on FunctionDef and ClassDef nodes.\n    \"\"\"\nif isinstance(node, cst.FunctionDef) or isinstance(node, cst.ClassDef):\nbody = node.body.body\nif body and isinstance(body[0], cst.SimpleStatementLine):\nstmt = body[0].body[0]\nif isinstance(stmt, cst.Expr) and isinstance(stmt.value, cst.SimpleString):\nreturn True\nreturn False\n</code></pre>"},{"location":"reference/cst/#write_the.cst.utils.nodes_to_tree","title":"<code>nodes_to_tree(nodes)</code>","text":"<p>Converts a list of CSTNodes into a CSTModule.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list[cst.CSTNode]</code> <p>The list of nodes to convert.</p> required <p>Returns:</p> Type Description <p>cst.Module: The CSTModule containing the given nodes.</p> Source code in <code>write_the/cst/utils.py</code> <pre><code>def nodes_to_tree(nodes):\n\"\"\"\n    Converts a list of CSTNodes into a CSTModule.\n    Args:\n      nodes (list[cst.CSTNode]): The list of nodes to convert.\n    Returns:\n      cst.Module: The CSTModule containing the given nodes.\n    \"\"\"\nmodule = cst.Module(body=nodes)\nreturn module\n</code></pre>"},{"location":"reference/cst/#write_the.cst.utils.remove_docstring","title":"<code>remove_docstring(node)</code>","text":"<p>Removes the docstring from a CSTNode.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.CSTNode</code> <p>The node to remove the docstring from.</p> required <p>Returns:</p> Type Description <p>cst.CSTNode: The node with the docstring removed.</p> Source code in <code>write_the/cst/utils.py</code> <pre><code>def remove_docstring(node):\n\"\"\"\n    Removes the docstring from a CSTNode.\n    Args:\n      node (cst.CSTNode): The node to remove the docstring from.\n    Returns:\n      cst.CSTNode: The node with the docstring removed.\n    \"\"\"\nif not node.body.body:\nreturn node\nfirst_stmt = node.body.body[0]\nif isinstance(first_stmt, cst.SimpleStatementLine):\nstmt = first_stmt.body[0]\nif isinstance(stmt, cst.Expr) and isinstance(stmt.value, cst.SimpleString):\nnew_body = node.body.with_changes(body=node.body.body[1:])\nreturn node.with_changes(body=new_body)\nreturn node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_batcher.Background","title":"<code>Background</code>","text":"<p>             Bases: <code>Node</code></p> <p>A class representing a background in a CST tree.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>cst.CSTNode</code> <p>The CST node of the background.</p> required Source code in <code>write_the/cst/node_batcher.py</code> <pre><code>class Background(Node):\n\"\"\"\n    A class representing a background in a CST tree.\n    Args:\n      body (cst.CSTNode): The CST node of the background.\n    \"\"\"\ndef __init__(self, body) -&gt; None:\n\"\"\"\n        Initializes a Background object.\n        Args:\n          body (cst.CSTNode): The CST node of the background.\n        \"\"\"\nself.node = body\nself.name = \"background\"\nself.code = self.node.code\nencoding = tiktoken.encoding_for_model(\"gpt-4\")\nself.tokens = len(encoding.encode(self.code))\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_batcher.Background.__init__","title":"<code>__init__(body)</code>","text":"<p>Initializes a Background object.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>cst.CSTNode</code> <p>The CST node of the background.</p> required Source code in <code>write_the/cst/node_batcher.py</code> <pre><code>def __init__(self, body) -&gt; None:\n\"\"\"\n    Initializes a Background object.\n    Args:\n      body (cst.CSTNode): The CST node of the background.\n    \"\"\"\nself.node = body\nself.name = \"background\"\nself.code = self.node.code\nencoding = tiktoken.encoding_for_model(\"gpt-4\")\nself.tokens = len(encoding.encode(self.code))\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_batcher.Node","title":"<code>Node</code>","text":"<p>A class representing a node in a CST tree.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the node.</p> required <code>node</code> <code>cst.CSTNode</code> <p>The CST node.</p> required <code>code</code> <code>str</code> <p>The code of the node.</p> required <code>tokens</code> <code>int</code> <p>The number of tokens in the node.</p> required Source code in <code>write_the/cst/node_batcher.py</code> <pre><code>class Node:\n\"\"\"\n    A class representing a node in a CST tree.\n    Args:\n      name (str): The name of the node.\n      node (cst.CSTNode): The CST node.\n      code (str): The code of the node.\n      tokens (int): The number of tokens in the node.\n    \"\"\"\nname: str\nnode: cst.CSTNode\ncode: str\ntokens: int\ndef __init__(self, *, tree, node_name, response_size=80) -&gt; None:\n\"\"\"\n        Initializes a Node object.\n        Args:\n          tree (cst.Module): The CST tree.\n          node_name (str): The name of the node.\n          response_size (int): The size of the response.\n        \"\"\"\nself.node = extract_node_from_tree(tree=tree, node=node_name)\nself.name = node_name\nself.code = get_code_from_node(self.node)\nencoding = tiktoken.encoding_for_model(\"gpt-4\")\nself.tokens = len(encoding.encode(self.code)) + response_size\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_batcher.Node.__init__","title":"<code>__init__(*, tree, node_name, response_size=80)</code>","text":"<p>Initializes a Node object.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.Module</code> <p>The CST tree.</p> required <code>node_name</code> <code>str</code> <p>The name of the node.</p> required <code>response_size</code> <code>int</code> <p>The size of the response.</p> <code>80</code> Source code in <code>write_the/cst/node_batcher.py</code> <pre><code>def __init__(self, *, tree, node_name, response_size=80) -&gt; None:\n\"\"\"\n    Initializes a Node object.\n    Args:\n      tree (cst.Module): The CST tree.\n      node_name (str): The name of the node.\n      response_size (int): The size of the response.\n    \"\"\"\nself.node = extract_node_from_tree(tree=tree, node=node_name)\nself.name = node_name\nself.code = get_code_from_node(self.node)\nencoding = tiktoken.encoding_for_model(\"gpt-4\")\nself.tokens = len(encoding.encode(self.code)) + response_size\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_batcher.NodeBatch","title":"<code>NodeBatch</code>  <code>dataclass</code>","text":"<p>A class representing a batch of nodes in a CST tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.Module</code> <p>The CST tree.</p> required <code>background</code> <code>Optional[Background]</code> <p>The background of the tree.</p> required <code>max_tokens</code> <code>int</code> <p>The maximum number of tokens in the batch.</p> required <code>prompt_size</code> <code>int</code> <p>The size of the prompt.</p> required <code>nodes</code> <code>List[Node]</code> <p>The list of nodes in the batch.</p> <code>field(default_factory=list)</code> <code>max_batch_size</code> <code>Optional[int]</code> <p>The maximum size of the batch.</p> <code>None</code> <code>send_node_context</code> <code>bool</code> <p>Whether to send the context of the nodes.</p> <code>False</code> Source code in <code>write_the/cst/node_batcher.py</code> <pre><code>@dataclass\nclass NodeBatch:\n\"\"\"\n    A class representing a batch of nodes in a CST tree.\n    Args:\n      tree (cst.Module): The CST tree.\n      background (Optional[Background]): The background of the tree.\n      max_tokens (int): The maximum number of tokens in the batch.\n      prompt_size (int): The size of the prompt.\n      nodes (List[Node]): The list of nodes in the batch.\n      max_batch_size (Optional[int]): The maximum size of the batch.\n      send_node_context (bool): Whether to send the context of the nodes.\n    \"\"\"\ntree: cst.Module\nbackground: Optional[Background]\nmax_tokens: int\nprompt_size: int\nnodes: List[Node] = field(default_factory=list)\nmax_batch_size: Optional[int] = None\nsend_node_context: bool = False\n@property\ndef tokens(self) -&gt; int:\n\"\"\"\n        Gets the number of tokens in the batch.\n        Returns:\n          int: The number of tokens in the batch.\n        \"\"\"\ntokens = self.prompt_size + sum(n.tokens for n in self.nodes)\nif self.background:\ntokens += self.background.tokens\nreturn tokens\n@property\ndef node_names(self) -&gt; List[str]:\n\"\"\"\n        Gets the names of the nodes in the batch.\n        Returns:\n          List[str]: The names of the nodes in the batch.\n        \"\"\"\nreturn [n.name for n in self.nodes]\n@property\ndef space_available(self) -&gt; int:\n\"\"\"\n        Gets the amount of space available in the batch.\n        Returns:\n          int: The amount of space available in the batch.\n        \"\"\"\nreturn self.max_tokens - self.tokens\n@property\ndef code(self):\n\"\"\"\n        Gets the code of the batch.\n        Returns:\n          str: The code of the batch.\n        \"\"\"\nif self.send_node_context:\n# send everything\nreturn self.tree.code\nif self.background:\n# remove all non batch nodes\nall_nodes = get_node_names(self.tree, True)\nclasses_to_keep = [n.split(\".\")[0] for n in self.node_names if \".\" in n]\nnodes_to_remove: List[str] = [\nn for n in all_nodes if n not in self.node_names\n]\nnodes_to_remove = [n for n in nodes_to_remove if n not in classes_to_keep]\nprocessed_tree = remove_nodes_from_tree(self.tree, nodes_to_remove)\nelse:\n# extract batch nodes\nextracted_nodes = extract_nodes_from_tree(self.tree, self.node_names)\nprocessed_tree = nodes_to_tree(extracted_nodes)\nreturn processed_tree.code\ndef add(self, node: Node):\n\"\"\"\n        Adds a node to the batch.\n        Args:\n          node (Node): The node to add.\n        Raises:\n          ValueError: If there is no space available in the batch.\n        \"\"\"\nif self.space_available - node.tokens &lt; 0 or (\nself.max_batch_size and len(self.nodes) + 1 &gt; self.max_batch_size\n):\nraise ValueError(\"No space available in batch!\")\nself.nodes.append(node)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_batcher.NodeBatch.code","title":"<code>code</code>  <code>property</code>","text":"<p>Gets the code of the batch.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The code of the batch.</p>"},{"location":"reference/cst/#write_the.cst.node_batcher.NodeBatch.node_names","title":"<code>node_names: List[str]</code>  <code>property</code>","text":"<p>Gets the names of the nodes in the batch.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The names of the nodes in the batch.</p>"},{"location":"reference/cst/#write_the.cst.node_batcher.NodeBatch.space_available","title":"<code>space_available: int</code>  <code>property</code>","text":"<p>Gets the amount of space available in the batch.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The amount of space available in the batch.</p>"},{"location":"reference/cst/#write_the.cst.node_batcher.NodeBatch.tokens","title":"<code>tokens: int</code>  <code>property</code>","text":"<p>Gets the number of tokens in the batch.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of tokens in the batch.</p>"},{"location":"reference/cst/#write_the.cst.node_batcher.NodeBatch.add","title":"<code>add(node)</code>","text":"<p>Adds a node to the batch.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node to add.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is no space available in the batch.</p> Source code in <code>write_the/cst/node_batcher.py</code> <pre><code>def add(self, node: Node):\n\"\"\"\n    Adds a node to the batch.\n    Args:\n      node (Node): The node to add.\n    Raises:\n      ValueError: If there is no space available in the batch.\n    \"\"\"\nif self.space_available - node.tokens &lt; 0 or (\nself.max_batch_size and len(self.nodes) + 1 &gt; self.max_batch_size\n):\nraise ValueError(\"No space available in batch!\")\nself.nodes.append(node)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_batcher.create_batches","title":"<code>create_batches(tree, node_names, max_tokens, prompt_size, response_size_per_node, max_batch_size=None, send_background_context=True, send_node_context=True, remove_docstrings=True)</code>","text":"<p>Creates batches of nodes from a tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.Module</code> <p>The tree to create batches from.</p> required <code>node_names</code> <code>List[str]</code> <p>The names of the nodes to create batches for.</p> required <code>max_tokens</code> <code>int</code> <p>The maximum number of tokens per batch.</p> required <code>prompt_size</code> <code>int</code> <p>The size of the prompt for each node.</p> required <code>response_size_per_node</code> <code>int</code> <p>The size of the response for each node.</p> required <code>max_batch_size</code> <code>Optional[int]</code> <p>The maximum number of nodes per batch.</p> <code>None</code> <code>send_background_context</code> <code>bool</code> <p>Whether to send background context.</p> <code>True</code> <code>send_node_context</code> <code>bool</code> <p>Whether to send node context.</p> <code>True</code> <code>remove_docstrings</code> <code>bool</code> <p>Whether to remove docstrings from the tree.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[NodeBatch]</code> <p>List[NodeBatch]: A list of batches of nodes.</p> Source code in <code>write_the/cst/node_batcher.py</code> <pre><code>def create_batches(\ntree,\nnode_names,\nmax_tokens,\nprompt_size,\nresponse_size_per_node,\nmax_batch_size=None,\nsend_background_context=True,\nsend_node_context=True,\nremove_docstrings=True,\n) -&gt; List[NodeBatch]:\n\"\"\"\n    Creates batches of nodes from a tree.\n    Args:\n      tree (cst.Module): The tree to create batches from.\n      node_names (List[str]): The names of the nodes to create batches for.\n      max_tokens (int): The maximum number of tokens per batch.\n      prompt_size (int): The size of the prompt for each node.\n      response_size_per_node (int): The size of the response for each node.\n      max_batch_size (Optional[int]): The maximum number of nodes per batch.\n      send_background_context (bool): Whether to send background context.\n      send_node_context (bool): Whether to send node context.\n      remove_docstrings (bool): Whether to remove docstrings from the tree.\n    Returns:\n      List[NodeBatch]: A list of batches of nodes.\n    \"\"\"\nif remove_docstrings:\ntree = remove_docstrings_from_tree(tree, node_names)  # TODO: fix to use Class.method syntax\nbatches = []\nbackground = None\nif send_background_context:\nbackground = extract_background(tree)\ndef create_batch():\n\"\"\"\n    Creates a batch of nodes from a tree.\n    Args:\n      tree (cst.Module): The tree to create batches from.\n      max_tokens (int): The maximum number of tokens per batch.\n      prompt_size (int): The size of the prompt for each node.\n      background (Optional[cst.Module]): The background context for the batch.\n      max_batch_size (Optional[int]): The maximum number of nodes per batch.\n      send_node_context (bool): Whether to send node context.\n    Returns:\n      NodeBatch: A batch of nodes.\n    \"\"\"\nreturn NodeBatch(\ntree=tree,\nmax_tokens=max_tokens,\nprompt_size=prompt_size,\nbackground=background,\nmax_batch_size=max_batch_size,\nsend_node_context=send_node_context,\n)\ncurrent_batch = create_batch()\nfor node_name in node_names:\nnode = Node(\ntree=tree, node_name=node_name, response_size=response_size_per_node\n)\ntry:\ncurrent_batch.add(node)\nexcept ValueError:\n# full\nbatches.append(current_batch)\ncurrent_batch = create_batch()\ncurrent_batch.add(node)\nbatches.append(current_batch)\nreturn batches\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_batcher.extract_background","title":"<code>extract_background(tree)</code>","text":"<p>Extracts the background from a CST tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.Module</code> <p>The CST tree.</p> required <p>Returns:</p> Name Type Description <code>Background</code> <p>The background of the tree.</p> Source code in <code>write_the/cst/node_batcher.py</code> <pre><code>def extract_background(tree):\n\"\"\"\n    Extracts the background from a CST tree.\n    Args:\n      tree (cst.Module): The CST tree.\n    Returns:\n      Background: The background of the tree.\n    \"\"\"\nall_node_names = get_node_names(tree, force=True)\nbackground = remove_nodes_from_tree(tree, all_node_names)\nreturn Background(body=background)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_extractor.NodeExtractor","title":"<code>NodeExtractor</code>","text":"<p>             Bases: <code>cst.CSTVisitor</code></p> Source code in <code>write_the/cst/node_extractor.py</code> <pre><code>class NodeExtractor(cst.CSTVisitor):\ndef __init__(self, nodes):\nself.nodes = nodes\nself.extracted_nodes = []\nself.current_class = None\ndef visit_FunctionDef(self, node: cst.FunctionDef):\n\"\"\"\n        Visits a FunctionDef node and adds it to the extracted_nodes list if its name is in the nodes list.\n        Args:\n          node (cst.FunctionDef): The FunctionDef node to visit.\n        Side Effects:\n          Modifies the extracted_nodes list of the NodeExtractor instance, adding the node if its name is in the nodes list.\n        \"\"\"\nname = (\nf\"{self.current_class}.{node.name.value}\"\nif self.current_class\nelse node.name.value\n)\nif name in self.nodes:\nself.extracted_nodes.append(node)\ndef visit_ClassDef(self, node: cst.ClassDef):\n\"\"\"\n        Visits a ClassDef node and sets the current_class attribute. If the class name is in the nodes list, it also adds the node to the extracted_nodes list.\n        Args:\n          node (cst.ClassDef): The ClassDef node to visit.\n        Side Effects:\n          Modifies the current_class attribute of the NodeExtractor instance, setting it to the name of the visited node. If the class name is in the nodes list, it also modifies the extracted_nodes list, adding the node.\n        \"\"\"\nself.current_class = node.name.value\nif node.name.value in self.nodes:\nself.extracted_nodes.append(node)\ndef leave_ClassDef(self, node: cst.ClassDef) -&gt; None:\nself.current_class = None\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_extractor.NodeExtractor.visit_ClassDef","title":"<code>visit_ClassDef(node)</code>","text":"<p>Visits a ClassDef node and sets the current_class attribute. If the class name is in the nodes list, it also adds the node to the extracted_nodes list.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.ClassDef</code> <p>The ClassDef node to visit.</p> required Side Effects <p>Modifies the current_class attribute of the NodeExtractor instance, setting it to the name of the visited node. If the class name is in the nodes list, it also modifies the extracted_nodes list, adding the node.</p> Source code in <code>write_the/cst/node_extractor.py</code> <pre><code>def visit_ClassDef(self, node: cst.ClassDef):\n\"\"\"\n    Visits a ClassDef node and sets the current_class attribute. If the class name is in the nodes list, it also adds the node to the extracted_nodes list.\n    Args:\n      node (cst.ClassDef): The ClassDef node to visit.\n    Side Effects:\n      Modifies the current_class attribute of the NodeExtractor instance, setting it to the name of the visited node. If the class name is in the nodes list, it also modifies the extracted_nodes list, adding the node.\n    \"\"\"\nself.current_class = node.name.value\nif node.name.value in self.nodes:\nself.extracted_nodes.append(node)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_extractor.NodeExtractor.visit_FunctionDef","title":"<code>visit_FunctionDef(node)</code>","text":"<p>Visits a FunctionDef node and adds it to the extracted_nodes list if its name is in the nodes list.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.FunctionDef</code> <p>The FunctionDef node to visit.</p> required Side Effects <p>Modifies the extracted_nodes list of the NodeExtractor instance, adding the node if its name is in the nodes list.</p> Source code in <code>write_the/cst/node_extractor.py</code> <pre><code>def visit_FunctionDef(self, node: cst.FunctionDef):\n\"\"\"\n    Visits a FunctionDef node and adds it to the extracted_nodes list if its name is in the nodes list.\n    Args:\n      node (cst.FunctionDef): The FunctionDef node to visit.\n    Side Effects:\n      Modifies the extracted_nodes list of the NodeExtractor instance, adding the node if its name is in the nodes list.\n    \"\"\"\nname = (\nf\"{self.current_class}.{node.name.value}\"\nif self.current_class\nelse node.name.value\n)\nif name in self.nodes:\nself.extracted_nodes.append(node)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_extractor.extract_nodes_from_tree","title":"<code>extract_nodes_from_tree(tree, nodes)</code>","text":"<p>Extracts specified nodes from a CST tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.CSTNode</code> <p>The CST tree to extract nodes from.</p> required <code>nodes</code> <code>list of str</code> <p>A list of node names to extract.</p> required <p>Returns:</p> Type Description <p>list of cst.CSTNode: A list of extracted nodes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; extract_nodes_from_tree(tree, ['FunctionDef', 'ClassDef'])\n[cst.FunctionDef, cst.ClassDef]\n</code></pre> Source code in <code>write_the/cst/node_extractor.py</code> <pre><code>def extract_nodes_from_tree(tree, nodes):\n\"\"\"\n    Extracts specified nodes from a CST tree.\n    Args:\n      tree (cst.CSTNode): The CST tree to extract nodes from.\n      nodes (list of str): A list of node names to extract.\n    Returns:\n      list of cst.CSTNode: A list of extracted nodes.\n    Examples:\n      &gt;&gt;&gt; extract_nodes_from_tree(tree, ['FunctionDef', 'ClassDef'])\n      [cst.FunctionDef, cst.ClassDef]\n    \"\"\"\nextractor = NodeExtractor(nodes)\ntree.visit(extractor)\nreturn extractor.extracted_nodes\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_remover.NodeRemover","title":"<code>NodeRemover</code>","text":"<p>             Bases: <code>cst.CSTTransformer</code></p> Source code in <code>write_the/cst/node_remover.py</code> <pre><code>class NodeRemover(cst.CSTTransformer):\ndef __init__(self, nodes):\n\"\"\"\n        Initializes a NodeRemover instance.\n        Args:\n          nodes (list): A list of nodes to remove.\n        \"\"\"\nself.nodes = nodes\nself.current_class = None\ndef leave_FunctionDef(\nself, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n) -&gt; cst.RemovalSentinel:\n\"\"\"\n        Removes a FunctionDef node from the tree if it is in the list of nodes to remove. The node is identified by its fully qualified name, which includes the class name if the function is a method.\n        Args:\n          original_node (cst.FunctionDef): The original FunctionDef node.\n          updated_node (cst.FunctionDef): The updated FunctionDef node.\n        Returns:\n          cst.RemovalSentinel: A sentinel indicating whether the node should be removed.\n        \"\"\"\nname = (\nf\"{self.current_class}.{original_node.name.value}\"\nif self.current_class\nelse original_node.name.value\n)\nif name in self.nodes:\nreturn cst.RemoveFromParent()\nreturn updated_node\ndef visit_ClassDef(self, original_node: cst.ClassDef) -&gt; None:\nself.current_class = original_node.name.value\ndef leave_ClassDef(\nself, original_node: cst.ClassDef, updated_node: cst.ClassDef\n) -&gt; cst.RemovalSentinel:\n\"\"\"\n        Removes a ClassDef node from the tree if it is in the list of nodes to remove.\n        Args:\n          original_node (cst.ClassDef): The original ClassDef node.\n          updated_node (cst.ClassDef): The updated ClassDef node.\n        Returns:\n          cst.RemovalSentinel: A sentinel indicating whether the node should be removed.\n        \"\"\"\nself.current_class = None\nif original_node.name.value in self.nodes:\nreturn cst.RemoveFromParent()\nreturn updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_remover.NodeRemover.__init__","title":"<code>__init__(nodes)</code>","text":"<p>Initializes a NodeRemover instance.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>A list of nodes to remove.</p> required Source code in <code>write_the/cst/node_remover.py</code> <pre><code>def __init__(self, nodes):\n\"\"\"\n    Initializes a NodeRemover instance.\n    Args:\n      nodes (list): A list of nodes to remove.\n    \"\"\"\nself.nodes = nodes\nself.current_class = None\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_remover.NodeRemover.leave_ClassDef","title":"<code>leave_ClassDef(original_node, updated_node)</code>","text":"<p>Removes a ClassDef node from the tree if it is in the list of nodes to remove.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.ClassDef</code> <p>The original ClassDef node.</p> required <code>updated_node</code> <code>cst.ClassDef</code> <p>The updated ClassDef node.</p> required <p>Returns:</p> Type Description <code>cst.RemovalSentinel</code> <p>cst.RemovalSentinel: A sentinel indicating whether the node should be removed.</p> Source code in <code>write_the/cst/node_remover.py</code> <pre><code>def leave_ClassDef(\nself, original_node: cst.ClassDef, updated_node: cst.ClassDef\n) -&gt; cst.RemovalSentinel:\n\"\"\"\n    Removes a ClassDef node from the tree if it is in the list of nodes to remove.\n    Args:\n      original_node (cst.ClassDef): The original ClassDef node.\n      updated_node (cst.ClassDef): The updated ClassDef node.\n    Returns:\n      cst.RemovalSentinel: A sentinel indicating whether the node should be removed.\n    \"\"\"\nself.current_class = None\nif original_node.name.value in self.nodes:\nreturn cst.RemoveFromParent()\nreturn updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_remover.NodeRemover.leave_FunctionDef","title":"<code>leave_FunctionDef(original_node, updated_node)</code>","text":"<p>Removes a FunctionDef node from the tree if it is in the list of nodes to remove. The node is identified by its fully qualified name, which includes the class name if the function is a method.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.FunctionDef</code> <p>The original FunctionDef node.</p> required <code>updated_node</code> <code>cst.FunctionDef</code> <p>The updated FunctionDef node.</p> required <p>Returns:</p> Type Description <code>cst.RemovalSentinel</code> <p>cst.RemovalSentinel: A sentinel indicating whether the node should be removed.</p> Source code in <code>write_the/cst/node_remover.py</code> <pre><code>def leave_FunctionDef(\nself, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n) -&gt; cst.RemovalSentinel:\n\"\"\"\n    Removes a FunctionDef node from the tree if it is in the list of nodes to remove. The node is identified by its fully qualified name, which includes the class name if the function is a method.\n    Args:\n      original_node (cst.FunctionDef): The original FunctionDef node.\n      updated_node (cst.FunctionDef): The updated FunctionDef node.\n    Returns:\n      cst.RemovalSentinel: A sentinel indicating whether the node should be removed.\n    \"\"\"\nname = (\nf\"{self.current_class}.{original_node.name.value}\"\nif self.current_class\nelse original_node.name.value\n)\nif name in self.nodes:\nreturn cst.RemoveFromParent()\nreturn updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_remover.remove_nodes_from_tree","title":"<code>remove_nodes_from_tree(tree, nodes)</code>","text":"<p>Removes specified nodes from a CST tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.CSTNode</code> <p>The CST tree to remove nodes from.</p> required <code>nodes</code> <code>list</code> <p>A list of nodes to remove.</p> required <p>Returns:</p> Type Description <p>cst.CSTNode: The updated CST tree after removal of specified nodes.</p> Source code in <code>write_the/cst/node_remover.py</code> <pre><code>def remove_nodes_from_tree(tree, nodes):\n\"\"\"\n    Removes specified nodes from a CST tree.\n    Args:\n      tree (cst.CSTNode): The CST tree to remove nodes from.\n      nodes (list): A list of nodes to remove.\n    Returns:\n      cst.CSTNode: The updated CST tree after removal of specified nodes.\n    \"\"\"\nremover = NodeRemover(nodes)\ntree = tree.visit(remover)\nreturn tree\n</code></pre>"},{"location":"reference/errors/","title":"Errors","text":""},{"location":"reference/errors/#write_the.errors.FileSkippedError","title":"<code>FileSkippedError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception raised when a file operation is intentionally skipped.</p> Source code in <code>write_the/errors.py</code> <pre><code>class FileSkippedError(Exception):\n\"\"\"\n    Exception raised when a file operation is intentionally skipped.\n    \"\"\"\n</code></pre>"},{"location":"reference/llm/","title":"Llm","text":""},{"location":"reference/llm/#write_the.llm.LLM","title":"<code>LLM</code>","text":"<p>A class for running a Language Model Chain.</p> Source code in <code>write_the/llm.py</code> <pre><code>class LLM:\n\"\"\"\n    A class for running a Language Model Chain.\n    \"\"\"\ndef __init__(self, prompt: PromptTemplate, temperature=0, model_name=\"gpt-3.5-turbo-instruct\"):\n\"\"\"\n        Initializes the LLM class.\n        Args:\n          prompt (PromptTemplate): The prompt template to use.\n          temperature (int, optional): The temperature to use for the model. Defaults to 0.\n          model_name (str, optional): The name of the model to use. Defaults to \"gpt-3.5-turbo-instruct\".\n        Side Effects:\n          Sets the class attributes.\n        Raises:\n          KeyError: If the model_name is not found in the models dictionary.\n        \"\"\"\nself.prompt = prompt\nself.prompt_size = self.number_of_tokens(prompt.template)\nself.temperature = temperature\nself.model_name = model_name\ntry:\nself.max_tokens = int(models[model_name][\"context_window\"])\nexcept KeyError:\nself.max_tokens = 4096\nif model_name.startswith('gpt-4'):\nself.max_tokens = 8192\nelif model_name.startswith('gpt-3'):\nself.max_tokens = 4096\nasync def run(self, code, **kwargs):\n\"\"\"\n        Runs the Language Model Chain asynchronously.\n        Args:\n          code (str): The code to use for the chain.\n          **kwargs (dict): Additional keyword arguments.\n        Returns:\n          str: The generated text.\n        \"\"\"\nif \"-instruct\" in self.model_name:\nllm = OpenAI(\ntemperature=self.temperature, max_tokens=-1, model_name=self.model_name\n)\nelse:\nllm = ChatOpenAI(\ntemperature=self.temperature, model_name=self.model_name\n)\nchain = LLMChain(llm=llm, prompt=self.prompt)\nreturn await chain.apredict(code=code, **kwargs)\ndef number_of_tokens(self, text):\n\"\"\"\n        Counts the number of tokens in a given text.\n        Args:\n          text (str): The text to count tokens for.\n        Returns:\n          int: The number of tokens in the text.\n        \"\"\"\nencoding = tiktoken.encoding_for_model(\"gpt-4\")\nreturn len(encoding.encode(text))\n</code></pre>"},{"location":"reference/llm/#write_the.llm.LLM.__init__","title":"<code>__init__(prompt, temperature=0, model_name='gpt-3.5-turbo-instruct')</code>","text":"<p>Initializes the LLM class.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>PromptTemplate</code> <p>The prompt template to use.</p> required <code>temperature</code> <code>int</code> <p>The temperature to use for the model. Defaults to 0.</p> <code>0</code> <code>model_name</code> <code>str</code> <p>The name of the model to use. Defaults to \"gpt-3.5-turbo-instruct\".</p> <code>'gpt-3.5-turbo-instruct'</code> Side Effects <p>Sets the class attributes.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the model_name is not found in the models dictionary.</p> Source code in <code>write_the/llm.py</code> <pre><code>def __init__(self, prompt: PromptTemplate, temperature=0, model_name=\"gpt-3.5-turbo-instruct\"):\n\"\"\"\n    Initializes the LLM class.\n    Args:\n      prompt (PromptTemplate): The prompt template to use.\n      temperature (int, optional): The temperature to use for the model. Defaults to 0.\n      model_name (str, optional): The name of the model to use. Defaults to \"gpt-3.5-turbo-instruct\".\n    Side Effects:\n      Sets the class attributes.\n    Raises:\n      KeyError: If the model_name is not found in the models dictionary.\n    \"\"\"\nself.prompt = prompt\nself.prompt_size = self.number_of_tokens(prompt.template)\nself.temperature = temperature\nself.model_name = model_name\ntry:\nself.max_tokens = int(models[model_name][\"context_window\"])\nexcept KeyError:\nself.max_tokens = 4096\nif model_name.startswith('gpt-4'):\nself.max_tokens = 8192\nelif model_name.startswith('gpt-3'):\nself.max_tokens = 4096\n</code></pre>"},{"location":"reference/llm/#write_the.llm.LLM.number_of_tokens","title":"<code>number_of_tokens(text)</code>","text":"<p>Counts the number of tokens in a given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to count tokens for.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of tokens in the text.</p> Source code in <code>write_the/llm.py</code> <pre><code>def number_of_tokens(self, text):\n\"\"\"\n    Counts the number of tokens in a given text.\n    Args:\n      text (str): The text to count tokens for.\n    Returns:\n      int: The number of tokens in the text.\n    \"\"\"\nencoding = tiktoken.encoding_for_model(\"gpt-4\")\nreturn len(encoding.encode(text))\n</code></pre>"},{"location":"reference/llm/#write_the.llm.LLM.run","title":"<code>run(code, **kwargs)</code>  <code>async</code>","text":"<p>Runs the Language Model Chain asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The code to use for the chain.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The generated text.</p> Source code in <code>write_the/llm.py</code> <pre><code>async def run(self, code, **kwargs):\n\"\"\"\n    Runs the Language Model Chain asynchronously.\n    Args:\n      code (str): The code to use for the chain.\n      **kwargs (dict): Additional keyword arguments.\n    Returns:\n      str: The generated text.\n    \"\"\"\nif \"-instruct\" in self.model_name:\nllm = OpenAI(\ntemperature=self.temperature, max_tokens=-1, model_name=self.model_name\n)\nelse:\nllm = ChatOpenAI(\ntemperature=self.temperature, model_name=self.model_name\n)\nchain = LLMChain(llm=llm, prompt=self.prompt)\nreturn await chain.apredict(code=code, **kwargs)\n</code></pre>"},{"location":"reference/models/","title":"Models","text":""},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#write_the.utils.list_python_files","title":"<code>list_python_files(directory)</code>","text":"<p>Finds all Python files in a given directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>The directory to search for Python files.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of Path objects for each Python file found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list_python_files(Path('/home/user/code'))\n[Path('/home/user/code/main.py'), Path('/home/user/code/utils.py')]\n</code></pre> Source code in <code>write_the/utils.py</code> <pre><code>def list_python_files(directory):\n\"\"\"\n    Finds all Python files in a given directory.\n    Args:\n      directory (Path): The directory to search for Python files.\n    Returns:\n      list: A list of Path objects for each Python file found.\n    Examples:\n      &gt;&gt;&gt; list_python_files(Path('/home/user/code'))\n      [Path('/home/user/code/main.py'), Path('/home/user/code/utils.py')]\n    \"\"\"\npython_files = []\nfor file in directory.glob(\"**/*.py\"):\npython_files.append(file)\nreturn python_files\n</code></pre>"}]}